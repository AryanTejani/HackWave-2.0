// lib/vulnerability-scoring.ts
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);

export interface VulnerabilityScore {
  nodeId: string;
  nodeType: 'supplier' | 'port' | 'route' | 'product' | 'shipment';
  nodeName: string;
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  factors: RiskFactor[];
  recommendations: string[];
  lastUpdated: Date;
}

export interface RiskFactor {
  name: string;
  weight: number; // 0-1
  score: number; // 0-100
  description: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
}

export interface NetworkAnalysis {
  chokepoints: Chokepoint[];
  singleSourceRisks: SingleSourceRisk[];
  countryDependencies: CountryDependency[];
  routeVulnerabilities: RouteVulnerability[];
}

export interface Chokepoint {
  location: string;
  type: 'port' | 'canal' | 'strait' | 'land_border';
  riskScore: number;
  affectedShipments: number;
  alternativeRoutes: string[];
  description: string;
}

export interface SingleSourceRisk {
  productId: string;
  productName: string;
  supplierId: string;
  supplierName: string;
  riskScore: number;
  impact: string;
  recommendations: string[];
}

export interface CountryDependency {
  country: string;
  dependencyScore: number;
  products: string[];
  suppliers: string[];
  riskFactors: string[];
}

export interface RouteVulnerability {
  route: string;
  riskScore: number;
  vulnerabilities: string[];
  affectedShipments: number;
  recommendations: string[];
}

export class VulnerabilityScoringSystem {
  private model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  // Risk scoring weights
  private readonly WEIGHTS = {
    VALUE_WEIGHT: 0.25,
    DELAY_PROBABILITY: 0.20,
    SUPPLIER_CONCENTRATION: 0.25,
    COUNTRY_RISK: 0.15,
    ROUTE_COMPLEXITY: 0.15
  };

  // Country risk indices (simplified - in real system, this would come from external APIs)
  private readonly COUNTRY_RISK_INDEX = {
    'China': 0.3,
    'USA': 0.2,
    'Germany': 0.15,
    'Japan': 0.2,
    'South Korea': 0.25,
    'India': 0.4,
    'Vietnam': 0.35,
    'Mexico': 0.3,
    'Brazil': 0.4,
    'Russia': 0.7,
    'Iran': 0.8,
    'Yemen': 0.9,
    'Ukraine': 0.8,
    'Turkey': 0.5,
    'Egypt': 0.6
  };

  async calculateVulnerabilityScore(
    nodeId: string,
    nodeType: VulnerabilityScore['nodeType'],
    nodeName: string,
    data: any,
    context: {
      shipments: any[];
      products: any[];
      suppliers: any[];
    }
  ): Promise<VulnerabilityScore> {
    const factors: RiskFactor[] = [];

    // Calculate value-based risk
    const valueRisk = this.calculateValueRisk(data, context);
    factors.push(valueRisk);

    // Calculate delay probability
    const delayRisk = this.calculateDelayRisk(data, context);
    factors.push(delayRisk);

    // Calculate supplier concentration risk
    const supplierRisk = this.calculateSupplierConcentrationRisk(data, context);
    factors.push(supplierRisk);

    // Calculate country risk
    const countryRisk = this.calculateCountryRisk(data);
    factors.push(countryRisk);

    // Calculate route complexity risk
    const routeRisk = this.calculateRouteComplexityRisk(data, context);
    factors.push(routeRisk);

    // Calculate overall risk score
    const riskScore = this.calculateOverallRiskScore(factors);
    const riskLevel = this.getRiskLevel(riskScore);

    // Generate AI-powered recommendations
    const recommendations = await this.generateVulnerabilityRecommendations(
      nodeType,
      nodeName,
      factors,
      riskLevel
    );

    return {
      nodeId,
      nodeType,
      nodeName,
      riskScore,
      riskLevel,
      factors,
      recommendations,
      lastUpdated: new Date()
    };
  }

  private calculateValueRisk(data: any, context: any): RiskFactor {
    const value = data.totalValue || data.value || 0;
    const maxValue = Math.max(...context.shipments.map((s: any) => s.totalValue || 0), 1);
    const valueScore = Math.min((value / maxValue) * 100, 100);

    return {
      name: 'Value Concentration',
      weight: this.WEIGHTS.VALUE_WEIGHT,
      score: valueScore,
      description: `High value concentration increases financial risk exposure`,
      impact: this.getImpactLevel(valueScore)
    };
  }

  private calculateDelayRisk(data: any, context: any): RiskFactor {
    const delayedShipments = context.shipments.filter((s: any) => 
      s.status === 'Delayed' || s.status === 'Stuck'
    ).length;
    const totalShipments = context.shipments.length;
    const delayProbability = totalShipments > 0 ? (delayedShipments / totalShipments) * 100 : 0;

    return {
      name: 'Delay Probability',
      weight: this.WEIGHTS.DELAY_PROBABILITY,
      score: delayProbability,
      description: `Historical delay patterns indicate future risk`,
      impact: this.getImpactLevel(delayProbability)
    };
  }

  private calculateSupplierConcentrationRisk(data: any, context: any): RiskFactor {
    const supplierId = data.supplierId || data.supplier;
    if (!supplierId) {
      return {
        name: 'Supplier Concentration',
        weight: this.WEIGHTS.SUPPLIER_CONCENTRATION,
        score: 0,
        description: 'No supplier information available',
        impact: 'low'
      };
    }

    const supplierShipments = context.shipments.filter((s: any) => 
      s.productId && context.products.find((p: any) => 
        p._id.toString() === s.productId.toString() && p.supplierId === supplierId
      )
    ).length;

    const totalShipments = context.shipments.length;
    const concentrationScore = totalShipments > 0 ? (supplierShipments / totalShipments) * 100 : 0;

    return {
      name: 'Supplier Concentration',
      weight: this.WEIGHTS.SUPPLIER_CONCENTRATION,
      score: concentrationScore,
      description: `High dependency on single supplier increases risk`,
      impact: this.getImpactLevel(concentrationScore)
    };
  }

  private calculateCountryRisk(data: any): RiskFactor {
    const country = this.extractCountry(data);
    const countryRisk = this.COUNTRY_RISK_INDEX[country] || 0.5;
    const countryScore = countryRisk * 100;

    return {
      name: 'Country Risk',
      weight: this.WEIGHTS.COUNTRY_RISK,
      score: countryScore,
      description: `Geopolitical and economic risks in ${country}`,
      impact: this.getImpactLevel(countryScore)
    };
  }

  private calculateRouteComplexityRisk(data: any, context: any): RiskFactor {
    const origin = data.origin || '';
    const destination = data.destination || '';
    
    // Simple route complexity scoring
    let complexityScore = 0;
    
    // Add points for long distances
    if (this.isLongDistance(origin, destination)) complexityScore += 30;
    
    // Add points for high-risk regions
    if (this.isHighRiskRegion(origin) || this.isHighRiskRegion(destination)) complexityScore += 40;
    
    // Add points for complex shipping methods
    if (data.shippingMethod === 'Air') complexityScore += 20;
    else if (data.shippingMethod === 'Sea') complexityScore += 30;

    return {
      name: 'Route Complexity',
      weight: this.WEIGHTS.ROUTE_COMPLEXITY,
      score: Math.min(complexityScore, 100),
      description: `Complex routes increase operational risk`,
      impact: this.getImpactLevel(complexityScore)
    };
  }

  private calculateOverallRiskScore(factors: RiskFactor[]): number {
    const weightedSum = factors.reduce((sum, factor) => {
      return sum + (factor.score * factor.weight);
    }, 0);

    return Math.min(Math.round(weightedSum), 100);
  }

  private getRiskLevel(score: number): 'low' | 'medium' | 'high' | 'critical' {
    if (score < 25) return 'low';
    if (score < 50) return 'medium';
    if (score < 75) return 'high';
    return 'critical';
  }

  private getImpactLevel(score: number): 'low' | 'medium' | 'high' | 'critical' {
    if (score < 25) return 'low';
    if (score < 50) return 'medium';
    if (score < 75) return 'high';
    return 'critical';
  }

  private extractCountry(data: any): string {
    const location = data.origin || data.destination || data.location || '';
    
    // Simple country extraction (in real system, use geocoding API)
    const countryMap: Record<string, string> = {
      'shanghai': 'China',
      'beijing': 'China',
      'shenzhen': 'China',
      'los angeles': 'USA',
      'new york': 'USA',
      'chicago': 'USA',
      'hamburg': 'Germany',
      'berlin': 'Germany',
      'tokyo': 'Japan',
      'osaka': 'Japan',
      'seoul': 'South Korea',
      'mumbai': 'India',
      'delhi': 'India',
      'ho chi minh': 'Vietnam',
      'hanoi': 'Vietnam',
      'mexico city': 'Mexico',
      'sao paulo': 'Brazil',
      'moscow': 'Russia',
      'istanbul': 'Turkey',
      'cairo': 'Egypt'
    };

    const lowerLocation = location.toLowerCase();
    for (const [city, country] of Object.entries(countryMap)) {
      if (lowerLocation.includes(city)) {
        return country;
      }
    }

    return 'Unknown';
  }

  private isLongDistance(origin: string, destination: string): boolean {
    // Simple heuristic for long distance
    const continents = {
      'asia': ['shanghai', 'beijing', 'tokyo', 'seoul', 'mumbai', 'delhi', 'ho chi minh', 'hanoi'],
      'europe': ['hamburg', 'berlin', 'london', 'paris', 'rome'],
      'americas': ['los angeles', 'new york', 'chicago', 'mexico city', 'sao paulo'],
      'africa': ['cairo', 'lagos', 'nairobi']
    };

    const originContinent = this.getContinent(origin, continents);
    const destContinent = this.getContinent(destination, continents);

    return originContinent !== destContinent && originContinent && destContinent;
  }

  private getContinent(location: string, continents: any): string | null {
    const lowerLocation = location.toLowerCase();
    for (const [continent, cities] of Object.entries(continents)) {
      if (cities.some(city => lowerLocation.includes(city))) {
        return continent;
      }
    }
    return null;
  }

  private isHighRiskRegion(location: string): boolean {
    const highRiskRegions = ['red sea', 'suez', 'strait of hormuz', 'south china sea', 'black sea'];
    return highRiskRegions.some(region => location.toLowerCase().includes(region));
  }

  async generateVulnerabilityRecommendations(
    nodeType: string,
    nodeName: string,
    factors: RiskFactor[],
    riskLevel: string
  ): Promise<string[]> {
    try {
      const highRiskFactors = factors.filter(f => f.impact === 'high' || f.impact === 'critical');
      
      const prompt = `
        Given this ${nodeType} vulnerability analysis:
        Node: ${nodeName}
        Risk Level: ${riskLevel}
        High Risk Factors: ${highRiskFactors.map(f => `${f.name} (${f.score}/100)`).join(', ')}
        
        Provide 3 specific, actionable recommendations to reduce vulnerability.
        Focus on practical strategies that can be implemented immediately.
        Return as a simple list of recommendations.
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const recommendations = response.text().split('\n').filter(rec => rec.trim());
      
      return recommendations.slice(0, 3);
    } catch (error) {
      console.error('Error generating vulnerability recommendations:', error);
      return [
        'Diversify suppliers to reduce concentration risk',
        'Implement real-time tracking and monitoring',
        'Develop contingency plans for high-risk routes'
      ];
    }
  }

  async analyzeNetworkVulnerabilities(context: {
    shipments: any[];
    products: any[];
    suppliers: any[];
  }): Promise<NetworkAnalysis> {
    const chokepoints = await this.identifyChokepoints(context);
    const singleSourceRisks = this.identifySingleSourceRisks(context);
    const countryDependencies = this.analyzeCountryDependencies(context);
    const routeVulnerabilities = await this.analyzeRouteVulnerabilities(context);

    return {
      chokepoints,
      singleSourceRisks,
      countryDependencies,
      routeVulnerabilities
    };
  }

  private async identifyChokepoints(context: any): Promise<Chokepoint[]> {
    // Analyze ports and routes for chokepoints
    const portUsage = new Map<string, number>();
    const routeUsage = new Map<string, number>();

    context.shipments.forEach((shipment: any) => {
      const origin = shipment.origin;
      const destination = shipment.destination;
      
      portUsage.set(origin, (portUsage.get(origin) || 0) + 1);
      portUsage.set(destination, (portUsage.get(destination) || 0) + 1);
      
      const route = `${origin}-${destination}`;
      routeUsage.set(route, (routeUsage.get(route) || 0) + 1);
    });

    const chokepoints: Chokepoint[] = [];

    // Identify high-usage ports as potential chokepoints
    for (const [port, usage] of portUsage.entries()) {
      if (usage > 3) { // Threshold for chokepoint
        const riskScore = Math.min(usage * 10, 100);
        chokepoints.push({
          location: port,
          type: 'port',
          riskScore,
          affectedShipments: usage,
          alternativeRoutes: await this.generateAlternativePorts(port),
          description: `High concentration of shipments through ${port}`
        });
      }
    }

    return chokepoints.slice(0, 5); // Top 5 chokepoints
  }

  private async generateAlternativePorts(port: string): Promise<string[]> {
    try {
      const prompt = `
        Given the port "${port}", suggest 3 alternative ports that could serve as backups.
        Focus on nearby ports with similar capabilities.
        Return as a simple list of port names.
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const alternatives = response.text().split('\n').filter(alt => alt.trim());
      
      return alternatives.slice(0, 3);
    } catch (error) {
      return ['Alternative Port 1', 'Alternative Port 2', 'Alternative Port 3'];
    }
  }

  private identifySingleSourceRisks(context: any): SingleSourceRisk[] {
    const productSupplierMap = new Map<string, Set<string>>();
    
    context.products.forEach((product: any) => {
      if (product.supplierId) {
        const productId = product._id.toString();
        if (!productSupplierMap.has(productId)) {
          productSupplierMap.set(productId, new Set());
        }
        productSupplierMap.get(productId)!.add(product.supplierId);
      }
    });

    const singleSourceRisks: SingleSourceRisk[] = [];

    for (const [productId, suppliers] of productSupplierMap.entries()) {
      if (suppliers.size === 1) {
        const product = context.products.find((p: any) => p._id.toString() === productId);
        const supplierId = Array.from(suppliers)[0];
        const supplier = context.suppliers.find((s: any) => s._id.toString() === supplierId);

        if (product && supplier) {
          singleSourceRisks.push({
            productId,
            productName: product.name,
            supplierId,
            supplierName: supplier.name,
            riskScore: 85, // High risk for single source
            impact: `Complete dependency on ${supplier.name} for ${product.name}`,
            recommendations: [
              'Identify and qualify alternative suppliers',
              'Develop supplier redundancy strategy',
              'Implement supplier risk monitoring'
            ]
          });
        }
      }
    }

    return singleSourceRisks;
  }

  private analyzeCountryDependencies(context: any): CountryDependency[] {
    const countryMap = new Map<string, {
      products: Set<string>;
      suppliers: Set<string>;
      riskFactors: Set<string>;
    }>();

    // Analyze products by country
    context.products.forEach((product: any) => {
      const country = this.extractCountry(product);
      if (!countryMap.has(country)) {
        countryMap.set(country, { products: new Set(), suppliers: new Set(), riskFactors: new Set() });
      }
      countryMap.get(country)!.products.add(product._id.toString());
    });

    // Analyze suppliers by country
    context.suppliers.forEach((supplier: any) => {
      const country = this.extractCountry(supplier);
      if (!countryMap.has(country)) {
        countryMap.set(country, { products: new Set(), suppliers: new Set(), riskFactors: new Set() });
      }
      countryMap.get(country)!.suppliers.add(supplier._id.toString());
    });

    const dependencies: CountryDependency[] = [];

    for (const [country, data] of countryMap.entries()) {
      const dependencyScore = Math.min((data.products.size + data.suppliers.size) * 10, 100);
      const countryRisk = this.COUNTRY_RISK_INDEX[country] || 0.5;
      
      if (countryRisk > 0.4) { // Only include high-risk countries
        dependencies.push({
          country,
          dependencyScore,
          products: Array.from(data.products),
          suppliers: Array.from(data.suppliers),
          riskFactors: [
            `High country risk index: ${Math.round(countryRisk * 100)}`,
            `${data.products.size} products sourced`,
            `${data.suppliers.size} suppliers located`
          ]
        });
      }
    }

    return dependencies.sort((a, b) => b.dependencyScore - a.dependencyScore);
  }

  private async analyzeRouteVulnerabilities(context: any): Promise<RouteVulnerability[]> {
    const routeMap = new Map<string, {
      shipments: any[];
      riskFactors: Set<string>;
    }>();

    context.shipments.forEach((shipment: any) => {
      const route = `${shipment.origin}-${shipment.destination}`;
      if (!routeMap.has(route)) {
        routeMap.set(route, { shipments: [], riskFactors: new Set() });
      }
      routeMap.get(route)!.shipments.push(shipment);
    });

    const vulnerabilities: RouteVulnerability[] = [];

    for (const [route, data] of routeMap.entries()) {
      const riskFactors = new Set<string>();
      
      // Analyze route characteristics
      const [origin, destination] = route.split('-');
      
      if (this.isHighRiskRegion(origin) || this.isHighRiskRegion(destination)) {
        riskFactors.add('High-risk region');
      }
      
      if (this.isLongDistance(origin, destination)) {
        riskFactors.add('Long-distance route');
      }
      
      const delayedShipments = data.shipments.filter((s: any) => 
        s.status === 'Delayed' || s.status === 'Stuck'
      ).length;
      
      if (delayedShipments > 0) {
        riskFactors.add(`Historical delays: ${delayedShipments} shipments`);
      }

      const riskScore = Math.min(riskFactors.size * 25 + delayedShipments * 10, 100);

      if (riskScore > 30) { // Only include vulnerable routes
        vulnerabilities.push({
          route,
          riskScore,
          vulnerabilities: Array.from(riskFactors),
          affectedShipments: data.shipments.length,
          recommendations: await this.generateRouteRecommendations(route, Array.from(riskFactors))
        });
      }
    }

    return vulnerabilities.sort((a, b) => b.riskScore - a.riskScore).slice(0, 5);
  }

  private async generateRouteRecommendations(route: string, riskFactors: string[]): Promise<string[]> {
    try {
      const prompt = `
        Given this route vulnerability analysis:
        Route: ${route}
        Risk Factors: ${riskFactors.join(', ')}
        
        Provide 3 specific recommendations to improve route resilience.
        Focus on practical strategies for risk mitigation.
        Return as a simple list of recommendations.
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const recommendations = response.text().split('\n').filter(rec => rec.trim());
      
      return recommendations.slice(0, 3);
    } catch (error) {
      return [
        'Develop alternative route options',
        'Implement real-time monitoring and alerts',
        'Establish contingency plans for disruptions'
      ];
    }
  }
}

// Export singleton instance
export const vulnerabilityScoring = new VulnerabilityScoringSystem();
